---
title: 正则表达式
tag:
 - 正则表达式学习记录
---

### 1.1   正则表达式的使用

#### 1.1.1   正则表达式的使用示例（一）

* 使用`?`和`*`通配符来查找硬盘上的文件，`?`通配符匹配文件名中的0或1个字符，`*`通配符匹配0个或多个字符。

* 如果使用`data(\w)?.dat`来查找文件的话，可能会查找出下列文件

  * | data.dat      |
    | ------------- |
    | **data1.dat** |
    | **data2.dat** |
    | **dataN.dat** |
    | **datax.dat** |

* 如果使用`*`字符代替`?`字符，就会扩大文件的查询范围，`data.*\.dat`可能会查找到以下文件

  * | data.dat        |
    | --------------- |
    | **data1.dat**   |
    | **data2.dat**   |
    | **data12.dat**  |
    | **datax.dat**   |
    | **dataXYZ.dat** |

    </br>

#### 1.1.2   正则表达式的使用示例（二）

* 例如：

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919103727168.png" alt="image-20210919103727168" style="zoom:80%;" />

* `^`为匹配输入字符串开始的位置
* `[0-9]+`匹配多个数字，`[0-9]`匹配单个数字，`+`匹配一个或多个
* `abc$`匹配字母`abc`并以`abc`结尾，`$`为匹配输入字符串的结束位置

</br>

**如果想让用户在注册账号时，只允许用户名包括字符、数字、下划线和连接字符(-)，并限制用户名长度，就可以用正则表达式**

* 例如：

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919104335642.png" alt="image-20210919104335642" style="zoom:80%;" />

**以上的正则表达式可以匹配`kibo24`，`kibou24`，`kibou_24`，但是不能匹配`ki`，因为太短了；也不能匹配`kibou$`，因为其包含特殊字符**

</br>

</br>

### 1.2   正则表达式的语法

#### 1.2.1   普通字符

| 字符   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| [ABC]  | 匹配`[...]`中的所有字符                                      |
| [^ABC] | 匹配除了`[...]`中的所有字符                                  |
| [A-Z]  | `[A-Z] `表示一个区间，匹配所有大写字母。`[a-z]` 表示所有小写字母 |
| .      | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 `[^\n\r]`   |
| [\s\S] | 匹配所有    ` \s` 是匹配所有空白符，包括换行，`\S` 非空白符，不包括换行 |
| \w     | 匹配字母、数字、下划线。等价于 `[A-Za-z0-9_]`                |

</br>

</br>

#### 1.2.2   非打印字符

| 字符   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| \cx    | 匹配由x指明的控制字符。例如， `\cM`匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符 |
| \f     | 匹配一个换页符。等价于 `\x0c` 和`\cL`                        |
| \n     | 匹配一个换行符。等价于 `\x0a` 和 `\cJ`                       |
| \r     | 匹配一个回车符。等价于 `\x0d` 和 `\cM`                       |
| **\s** | **匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符** |
| **\S** | **匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`**              |
| \t     | 匹配一个制表符。等价于 `\x09` 和` \cI`                       |
| \v     | 匹配一个垂直制表符。等价于 `\x0b` 和` \cK`                   |

</br>

</br>

#### 1.2.3   特殊字符

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| $    | **匹配输入字符串的结尾位置**。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 也匹配 `\n` 或 `\r`。要匹配 `$` 字符本身，请使用 `\$` |
| ()   | **标记一个子表达式的开始和结束位置**。子表达式可以获取供以后使用。要匹配这些字符，请使用` \(` 和` \)` |
| *    | 匹配**前面的子表达式零次或多次**。要匹配 `*` 字符，请使用 `\*` |
| +    | 匹配**前面的子表达式一次或多次**。要匹配` + `字符，请使用 `\+` |
| .    | 匹配除换行符 `\n` 之外的任何单字符。要匹配` . `，请使用` \.` |
| [    | 标记一个中括号表达式的开始。要匹配 `[`，请使用` \[`          |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?` |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `n` 匹配字符 `n`。`\n` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 "(" |
| ^    | **匹配输入字符串的开始位置**，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 `^ `字符本身，请使用 `\^` |
| {}   | 标记限定符表达式的开始。要匹配 `{`，请使用 `\{`              |
| \|   | 指明两项之间的一个选择。要匹配`|`，请使用` \|`               |

</br>

</br>

#### 1.2.4   限定符

| 字符  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| *     | **匹配前面的子表达式零次或多次**。例如，`zo*` 能匹配 `z` 以及 `zoo`。* 等价于`{0,}`。 |
| +     | **匹配前面的子表达式一次或多次**。例如，`zo+`能匹配 `zo` 以及 `zoo`，但不能匹配 `z`。+ 等价于` {1,}`。 |
| ?     | **匹配前面的子表达式零次或一次**。例如，`do(es)?` 可以匹配 `do` 、 `does` 中的 `does` 、 `doxy` 中的 `do` 。`?` 等价于` {0,1}`。 |
| {n}   | n 是一个非负整数。**匹配确定的 n 次**。例如，`o{2}` 不能匹配 `Bob` 中的 `o`，但是能匹配 `food` 中的两个 o。 |
| {n,}  | n 是一个非负整数。**至少匹配n 次**。例如，`o{2,}` 不能匹配 `Bob` 中的 `o`，但能匹配 `foooood` 中的所有 `o`。`o{1,}` 等价于 `o+`。`o{0,}` 则等价于 `o*`。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。**最少匹配 n 次且最多匹配 m 次**。例如，`o{1,3}` 将匹配 `fooooood` 中的前三个 o。`o{0,1}` 等价于 `o?`。注意在逗号和两个数之间不能有空格。 |

</br>

**`*`和`+`限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配**

</br>

</br>

#### 1.2.5   定位符

* 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

* 定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\b** 描述单词的前或后边界，**\B** 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即**字与空格**间的位置。                   |
| \B   | 非单词边界匹配。                                             |

**注意**：

* 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

* 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式内的用法混淆。

* 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

* 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

```
^Chapter [1-9][0-9]{0,1}
```

真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它既出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。

```
^Chapter [1-9][0-9]{0,1}$
```

匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。**单词边界是单词和空格之间的位置。非单词边界是任何其他位置。**下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：

```
\bCha
```

**\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：

```
ter\b
```

下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：

```
\Bapt
```

字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 **\B** 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。

</br>

</br>

#### 1.2.6   选择

* 用圆括号 **()** 将所有选择项括起来，相邻的选择项之间用 **|** 分隔。

* **()** 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(**n** 是一个数字，表示第 n 个捕获组的内容)。

```
([1-9])([a-z]+)
```

*可以匹配以一个数字开头，后面是一个或多个小写字母的*内容

*如   12345`6ershisi`2423`3kibou`24*

</br>

* **?=、?<=、?!、?<! 的使用区别**

  * ?=

  ```
  exp1(?=exp2):查找exp2前面的exp1
  ```

  * ?<=

  ```
  (?<=exp2)exp1:查找exp2后面的exp1
  ```

  * ?!

  ```:
  exp1(?!exp2):查找后面不是exp2的exp1
  ```

  * ?<!

  ```
  (?<!exp2)exp1:查找前面不是exp2的exp1
  ```

</br>

</br>

### 1.3   DFA

**DFA为确定有限自动机。DFA为一个五元组<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919121128641.png" alt="image-20210919121128641" style="zoom: 50%;" />，其中：**

* Σ是一个有穷字母表，它的每一个元素称为**输入字符**
* S是**状态**的集合，它的每一个元素称为一个**状态**
* S0∈S，是确定有限自动机**唯一的一个初始状态**
* f是在s×Σ->S上的**转换函数**
* Z包含于S，是一个**终止状态集**，又称为接收状态集

</br>

#### 1.3.1   DFA的确定性

* 初始状态唯一
* f:s×Σ->S是单值函数，即对任意状态s∈S，和输入符号a∈Σ，都有f(s,a)唯一确定下一个状态，即最多确定一个状态
* 如S={0,1,2}，Σ={a,b}，f(0,a)=1，f(0,b)=2，f(1,a)=2
  * **一个状态接收一个符号，对应一个值**

</br>

#### 1.3.2   DFA的表示

* 状态转移矩阵
  * 约定：第一行表示初始状态S0，或者在右上角标注`+` ，`*`或`-`表示终止状态

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919122531586.png" alt="image-20210919122531586" style="zoom:67%;" />

</br>

</br>

* 状态转换函数
  * 节点表示状态，变表示转换函数，方向表示转换方向
  * 初始状态：一个入箭头
  * 终止状态：两个同心圆

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919123614160.png" alt="image-20210919123614160" style="zoom:67%;" />

</br>

* DFA接受的串

**对于Σ*中任何字符串t，若存在一条从初始结点到某一终止结点的路径，且这条路上所有边的标记符连接成的字符串等于t，则称t可被DFA M接受（识别、合法），所有t的集合记为L(M).**

</br>

#### 1.3.3   DFA的使用例（一）

* 使用DFA表示能被3整除的十进制数

  *0/3/6/9表示当前数字加上0/3/6/9以后对3的余数*

| 状态（余数） | 0/3/6/9 | 1/4/7 | 2/5/8 |
| :----------: | :-----: | :---: | :---: |
|      0       |    0    |   1   |   2   |
|      1       |    1    |   2   |   0   |
|      2       |    2    |   0   |   1   |

* 由表格可得DFA图
  * 输入一个数，如果最后能回到终止状态0，就说明其能被3整除

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919131605119.png" alt="image-20210919131605119" style="zoom:67%;" />

</br>

</br>

#### 1.3.4   DFA的使用例（二）

* 用DFA表示能被4整除的**2进制数**
  * 这里状态一列用**二进制数**表示
  * 添表示在数字的后方添加上0/1这个字符，而不是指相加

| 状态（余数） | 添0  | 添1  |
| :----------: | :--: | :--: |
|      0       |  0   |  1   |
|      1       |  2   |  3   |
|      10      |  0   |  1   |
|      11      |  2   |  3   |

* 由表格可得DFA图

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919134922204.png" alt="image-20210919134922204" style="zoom:67%;" />

</br>

### 1.4   NFA

**NFA是非确定有限自动机，为一个五元组<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919121128641.png" alt="image-20210919121128641" style="zoom: 50%;" />，其中：**

* Σ是一个有穷字母表，它的每一个元素称为**输入字符**
* S是**状态**的集合，它的每一个元素称为一个**状态**
* S0∈S，是非确定有限自动机的**初始状态集**
* f是在s×Σ->S上的**转换函数**
* Z包含于S，是一个**终止状态集**，又称为接收状态集

</br>

### 1.5   自动机等价

**A1，A2是同一个字母表上的自动机，若有L(A1)=L(A2)，则两个自动机等价**

* 对于每一个NFA，总存在一个DFA，使二者等价

</br>

#### 1.5.1   闭包

状态集的I闭包 ε-CLOSURE(I)为：

* 若q∈I，则q∈ε-CLOSURE(I)
* 若q∈I，则从q出发经任意条ε弧能到达的任何状态q'，都属于ε-CLOSURE(I)

**含有NFA终止状态的新状态为终止状态**

</br>

**ε-closure(s)表示由状态s经由条件ε（空串）可以到达的所有状态的集合**

~~上面的定义说的是真的烦~~

</br>

#### 1.5.2   自动机转换的示例

**现有如图NFA：**

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919194432443.png" alt="image-20210919194432443" style="zoom:67%;" />

</br>

* 状态转换表

|      |   a   |   b   | **ε** |
| :--: | :---: | :---: | :---: |
|  0   | **∅** | **∅** |  1,7  |
|  1   | **∅** | **∅** |  2,4  |
|  2   |   3   | **∅** | **∅** |
|  3   | **∅** | **∅** |   6   |
|  4   | **∅** |   5   | **∅** |
|  5   | **∅** | **∅** |   6   |
|  6   | **∅** | **∅** |  1,7  |
|  7   |   8   | **∅** | **∅** |
|  8   | **∅** |   9   | **∅** |
|  9   | **∅** | **∅** | **∅** |

</br>

* 求出ε-closure(s)

  **ε-closure(s)表示由状态s经由条件ε（空串）可以到达的所有状态的集合**

  * **ε-closure(0)={0,1,2,4,7}**
  * **ε-closure(1)={1,2,4}**
  * **ε-closure(2)={2}**
  * **ε-closure(3)={1,2,3,4,6,7}**
  * **ε-closure(4)={4}**
  * **ε-closure(5)={1,2,4,5,6,7}**
  * **ε-closure(6)={1,2,4,6,7}**
  * **ε-closure(7)={7}**
  * **ε-closure(8)={8}**
  * **ε-closure(9)={9}**

</br>

* 开始转换

首先将初始态的转换闭包ε-closure(0)设为状态A，即A={0,1,2,4,7}，**注意这里的状态A是DFA中的，和前面的状态0,1,2,3,4,5没有关系**

接着**写出状态A经过上面转换图中所有转换条件得到的状态**，后继状态里面不包括自身，这里的转换条件包括a和b，注意，**不包括ε**，转换的一个目的就是**消除ε**。

</br>

**move（I，a）是从I中的某一状态经过一条a弧而到达的状态全体。**

**move(A,a)也就是图中从{0,1,2,4,7}其中的某一状态出发的a弧指向的状态的集合，即:**

**move(A,a)={3,8}，move(A,b)={5}**

</br>

* **ε-closure(0) = A**
* **ε-closure(move(A,a)) = ε-closure({3,8}) = {1,2,3,4,6,7,8} = B**
* **ε-closure(move(A,b)) = ε-closure(5) = {1,2,4,5,6,7} = C**
* **ε-closure(move(B,a)) = ε-closure({3,8}) = {1,2,3,4,6,7,8} = B**
* **ε-closure(move(B,b)) = ε-closure({5,9}) = {1,2,4,5,6,7,9} = D**
* **ε-closure(move(C,a)) = ε-closure({3,8}) = {1,2,3,4,6,7,8} = B**
* **ε-closure(move(C,b)) = ε-closure(5) = {1,2,4,5,6,7} = C**
* **ε-closure(move(D,a)) = ε-closure({3,8}) = {1,2,3,4,6,7,8} = B**
* **ε-closure(move(D,b)) = ε-closure(5) = {1,2,4,5,6,7} = C**

</br>

由以上可得DFA的转换表

| 状态 |  a   |  b   |
| :--: | :--: | :--: |
|  A   |  B   |  C   |
|  B   |  B   |  D   |
|  C   |  B   |  C   |
|  D   |  B   |  C   |

</br>

由转换表可以画出DFA转换图

<img src="https://kibo24-1305312055.cos.ap-beijing.myqcloud.com/image-20210919202903552.png" alt="image-20210919202903552" style="zoom: 80%;" />

</br>

</br>

**至此NFA转化为DFA完成！**














